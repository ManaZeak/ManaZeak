package org.manazeak.manazeak.controller.rest.library.track;

import com.google.common.escape.UnicodeEscaper;
import com.google.common.net.PercentEscaper;
import jakarta.validation.constraints.NotNull;
import lombok.RequiredArgsConstructor;
import org.manazeak.manazeak.configuration.security.rest.RestSecurity;
import org.manazeak.manazeak.constant.security.PrivilegeEnum;
import org.manazeak.manazeak.entity.dto.kommunicator.KommunicatorDto;
import org.manazeak.manazeak.entity.dto.library.track.TrackQueueInfoDto;
import org.manazeak.manazeak.entity.track.Track;
import org.manazeak.manazeak.exception.MzkSecurityException;
import org.manazeak.manazeak.service.library.track.TrackService;
import org.manazeak.manazeak.service.message.KommunicatorService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;

@RestController
@RequiredArgsConstructor
public class TrackRestController {

    private static final String TRACK_URI_PREFIX = "http://";

    private final TrackService trackService;

    private final KommunicatorService kommunicatorService;

    private final JwtDecoder jwtDecoder;

    /**
     * Send a request to the nginx to play the given track.
     *
     * @param trackId The id of the track in the database.
     * @return The redirection to the nginx to
     */
    @GetMapping("/jwt_custom/play/{trackId}/")
    public ResponseEntity<Object> playTrackFromId(@PathVariable @NotNull(message = "general.error.no_id") Long trackId, @RequestParam String jwt) throws URISyntaxException {
        if (!isAuthorizedToPlay(jwt)) {
            throw new MzkSecurityException("Not auth", "Not authorized");
        }

        // Getting the track for the id.
        Track track = trackService.getTrackById(trackId);

        // Formatting the location with a percent escaper.
        UnicodeEscaper basicEscaper = new PercentEscaper("/", false);
        String locationEscaped = basicEscaper.escape(track.getLocation());
        String urlEscaped = basicEscaper.escape(TRACK_URI_PREFIX + track.getLocation());

        // Preparing the redirection to the nginx to serve the track.
        HttpHeaders header = new HttpHeaders();
        header.setLocation(new URI(urlEscaped));
        if (Boolean.TRUE.equals(track.getIsMp3())) {
            header.set("Content-Type", "audio/mpeg");
        } else {
            header.set("Content-Type", "audio/flac");
        }
        header.set("Content-Disposition", "inline");
        header.set("X-Accel-Redirect", locationEscaped);

        // Sending the response to the client.
        return new ResponseEntity<>(header, HttpStatus.SEE_OTHER);
    }

    /**
     * Checks if the user can play a track with its JWT token.
     *
     * @param jwt The JWT of the user.
     * @return If the user can play the track.
     */
    private boolean isAuthorizedToPlay(String jwt) {
        // Validating if the user can play the track.
        Jwt token = jwtDecoder.decode(jwt);
        Object scope = token.getClaims().get("scope");
        if (scope instanceof ArrayList<?> elements) {
            for (Object element : elements) {
                if (element instanceof String role) {
                    if (PrivilegeEnum.PLAY.name().equals(role)) {
                        return true;
                    }
                }
            }
        }
        // The user doesn't have the play role.
        return false;
    }

    /**
     * Send the tracks contained on the album of an artist.
     *
     * @param artistId The id of the artist.
     * @return The list of track elements.
     */
    @RestSecurity(PrivilegeEnum.PLAY)
    @GetMapping("/album/{artistId}/queue")
    public List<TrackQueueInfoDto> getAllTracksInAlbumFromArtistId(@PathVariable @NotNull Long artistId) {
        return trackService.getAllTracksForArtistAlbum(artistId);
    }

    /**
     * Delete a moodbar of a track. The moodbar will be regenerated by the moodbar container.
     *
     * @param trackId The id of the track.
     * @return Success message if the
     */
    @RestSecurity(PrivilegeEnum.RLPV)
    @GetMapping("/regenerate-mood/{trackId}/")
    public KommunicatorDto regenerateMoodbar(@PathVariable @NotNull(message = "general.error.no_id") Long trackId) {
        trackService.regenerateMoodbar(trackId);
        return kommunicatorService.buildSuccessKom("user.track.delete.mood_title", "user.track.delete.mood");
    }

}
